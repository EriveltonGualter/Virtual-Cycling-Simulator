#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Nov 13 23:38:14 2018

This code is to generate dynamics equation of a 4 DoF multi-bodies system for cycling

@author: huawei
"""

from collections import OrderedDict
import sympy as sy
import sympy.physics.mechanics as me

sym_kwargs = {'positive': True, 'real': True}
me.dynamicsymbols._t = sy.symbols('t', **sym_kwargs)


class PlanarCyclingModel4Segments(object):
    
    """
    In this class we are going to make a simple model of a human cycling model
    We will make several assumptions:

        - The human's motion is limited to a 2D plane (i.e. leaning backwards and forwards).
        - The model have four links: Left Thigh, Left Shank, Right Thigh, Right Shank.
        - The model have 4 degrees of freedom: rotation of l/r thigh, l/r shank
        - The forces generated by the muscles will be modeled as ideal torques between the adjacent body segments.
        - There is a contact point at the external point of shank, which generate contact force with environment (petals).
    
    Reference Frames
    ----------------
    
        There are five reference frames and nine important points. The inertial reference frame,
        $I$, is rigidly attached to the ground. The left thigh reference frame,
        $LT$, is attached to the inertial reference by a pin joint at the hip point $H$ and rotates relative to the trunk
        through $\theta_1$. The left shank reference frame, $LS$, is attached to the left shank by a pin joint at
        left knee point $LK$ and rotates relative to the left thigh through angle $\theta_2$. The right thigh
        reference frame, $RT$, is attached to the inertial reference frame by a pin joint at the hip point $H$ and rotates relative
        to the trunk through $\theta_3$. The left shank reference frame, $RS$, is attached to the left shank by
        a pin joint at right knee point $RK$ and rotates relative to the left thigh through angle $\theta_4$..
        Note that all rotations are about the $z$ axis and that they are relative to the orientation of the preceding body.
    
    Geometry
    --------
    
        The thigh and shank's lengths are defined as $l_T$ and $l_S$.
    
    Mass Centers
    -------------
    
        The four points $LT_o$, $LS_o$, $RT_o$, $RL_o$ are the mass centers of the body segments. 
        These are each located on the line connecting the proximal and distal joints of each body segment
        and are located by the dimensions: $d_{T}$, and $d_{S}$.
    
    Gravity
    -------
    
        Gravity is directed downwards ($-y$) and applies a force with a magnitude of $m_T, m_S$ at each mass center, respectively.
    
    Torques
    -------
    
        Two forces and five torques represent the forces due to muscles contracting.
        Two forces are the $x$ and $y$ direction force on the trunk. Four torques are
        the torque on left legs $T_{LH}$, knee $T_{LK}$, and torques on right legs $T_{RH}$, $T_{RK}$,
        torques apply equal and opposite torques to the adjoining body segments.
    """
    
    def __init__(self, implicit = True):
        
        """
        Parameters
        ==========
        implicit : boolean
            This boolean parameter that determined whether the dyanmic equation implicit or explicit
        """
        self.implicit = implicit
        
    
    def _create_states(self):

        self.time = me.dynamicsymbols._t

        syms_q = 'theta_lh, theta_lk, theta_rh, theta_rk'
        syms_u = 'omega_lh, omega_lk, omega_rh, omega_rk'
        syms_a = 'beta_lh, beta_lk, beta_rh, beta_rk'
        
        time_varying_q = [s(self.time) for s in
                        sy.symbols(syms_q, cls=sy.Function, real=True)]
        
        time_varying_u = [s(self.time) for s in
                        sy.symbols(syms_u, cls=sy.Function, real=True)]
        
        self.time_varying_a = [s(self.time) for s in
                        sy.symbols(syms_a, cls=sy.Function, real=True)]

        self.coordinates = OrderedDict()
        self.coordinates['left_hip'] = time_varying_q[0]
        self.coordinates['left_knee'] = time_varying_q[1]
        self.coordinates['right_hip'] = time_varying_q[2]
        self.coordinates['right_knee'] = time_varying_q[3]

        self.speeds = OrderedDict()
        self.speeds['left_hip'] = time_varying_u[0]
        self.speeds['left_knee'] = time_varying_u[1]
        self.speeds['right_hip'] = time_varying_u[2]
        self.speeds['right_knee'] = time_varying_u[3]
        
        self.accelerations = OrderedDict()
        self.accelerations['left_hip'] = self.time_varying_a[0]
        self.accelerations['left_knee'] = self.time_varying_a[1]
        self.accelerations['right_hip'] = self.time_varying_a[2]
        self.accelerations['right_knee'] = self.time_varying_a[3]
        
        
    def _create_specified(self):
                        
        self.time_varying_F = [s(self.time) for s in sy.symbols('F_lx, F_ly, F_rx, F_ry', 
                                            cls=sy.Function, real=True)]
                        
        self.time_varying_T = [s(self.time) for s in sy.symbols('T_lh, T_lk, T_rh, T_rk', 
                                            cls=sy.Function, real=True)]

        self.specified = OrderedDict()
        self.specified['left_force_x'] = self.time_varying_F[0]
        self.specified['left_force_y'] = self.time_varying_F[1]
        self.specified['right_force_x'] = self.time_varying_F[2]
        self.specified['right_force_y'] = self.time_varying_F[3]
        self.specified['left_hip_torque'] = self.time_varying_T[0]
        self.specified['left_knee_torque'] = self.time_varying_T[1]
        self.specified['right_hip_torque'] = self.time_varying_T[2]
        self.specified['right_knee_torque'] = self.time_varying_T[3]

    def _create_parameters(self):
        
        self.parameter_strings = sy.symbols('l_St, l_T, l_S, d_T, d_S, m_T, m_S, i_T, i_S, g', **sym_kwargs)

        self.parameters = OrderedDict()
        self.parameters['seat_height'] = self.parameter_strings[0]
        self.parameters['thigh_length'] = self.parameter_strings[1]
        self.parameters['shank_length'] = self.parameter_strings[2]
        self.parameters['thigh_com_length'] = self.parameter_strings[3]
        self.parameters['shank_com_length'] = self.parameter_strings[4]
        self.parameters['thigh_mass'] = self.parameter_strings[5]
        self.parameters['shank_mass'] = self.parameter_strings[6]
        self.parameters['thigh_inertia'] = self.parameter_strings[7]
        self.parameters['shank_inertia'] = self.parameter_strings[8]
        self.parameters['g'] = self.parameter_strings[9]
        
    def _create_reference_frames(self):
        
        # Set Reference Frames
        
        self.frames = OrderedDict()
        
        self.frames['inertial'] = me.ReferenceFrame('I')
        
        self.frames['left_thigh'] = me.ReferenceFrame('LT')
        self.frames['left_shank'] = me.ReferenceFrame('LS')
        
        self.frames['right_thigh'] = me.ReferenceFrame('RT')
        self.frames['right_shank'] = me.ReferenceFrame('RS')
        
    def _orient_reference_frames(self):

        self.frames['left_thigh'].orient(self.frames['inertial'],
                                  'Axis',
                                  (self.coordinates['left_hip'],
                                   self.frames['inertial'].z))

        self.frames['left_shank'].orient(self.frames['left_thigh'],
                                    'Axis',
                                    (self.coordinates['left_knee'],
                                     self.frames['left_thigh'].z))
        
        self.frames['right_thigh'].orient(self.frames['inertial'],
                                  'Axis',
                                  (self.coordinates['right_hip'],
                                   self.frames['inertial'].z))

        self.frames['right_shank'].orient(self.frames['right_thigh'],
                                    'Axis',
                                    (self.coordinates['right_knee'],
                                     self.frames['right_thigh'].z))
    
    def _create_points(self):

        self.points = OrderedDict()
        self.points['origin'] = me.Point('O')
        self.points['hip'] = me.Point('H')
        self.points['lknee'] = me.Point('LK')
        self.points['lankle'] = me.Point('LA')
        self.points['rknee'] = me.Point('RK')
        self.points['rankle'] = me.Point('RA')
        self.points['lthigh_mass_center'] = me.Point('LT_o')
        self.points['lshank_mass_center'] = me.Point('LS_o')
        self.points['rthigh_mass_center'] = me.Point('RT_o')
        self.points['rshank_mass_center'] = me.Point('RS_o')
        
    
    def _set_positions(self):

        vec = self.parameters['seat_height'] * self.frames['inertial'].y
        self.points['hip'].set_pos(self.points['hip'], vec)

        vec = -self.parameters['thigh_length'] * self.frames['left_thigh'].y
        self.points['lknee'].set_pos(self.points['hip'], vec)

        vec = -self.parameters['shank_length'] * self.frames['left_shank'].y
        self.points['lankle'].set_pos(self.points['lknee'], vec)
        
        vec = -self.parameters['thigh_length'] * self.frames['right_thigh'].y
        self.points['rknee'].set_pos(self.points['hip'], vec)

        vec = -self.parameters['shank_length'] * self.frames['right_shank'].y
        self.points['rankle'].set_pos(self.points['rknee'], vec)

        vec = -self.parameters['thigh_com_length'] * self.frames['left_thigh'].y
        self.points['lthigh_mass_center'].set_pos(self.points['hip'], vec)
        
        vec = -self.parameters['shank_com_length'] * self.frames['left_shank'].y
        self.points['lshank_mass_center'].set_pos(self.points['lknee'], vec)
        
        vec = -self.parameters['thigh_com_length'] * self.frames['right_thigh'].y
        self.points['rthigh_mass_center'].set_pos(self.points['hip'], vec)
        
        vec = -self.parameters['shank_com_length'] * self.frames['right_shank'].y
        self.points['rshank_mass_center'].set_pos(self.points['rknee'], vec)
        
    def _define_kin_diff_eqs(self):

        self.kin_diff_eqs = (self.speeds['left_hip'] -
                             self.coordinates['left_hip'].diff(self.time),
                             self.speeds['left_knee'] -
                             self.coordinates['left_knee'].diff(self.time),
                             self.speeds['right_hip'] -
                             self.coordinates['right_hip'].diff(self.time),
                             self.speeds['right_knee'] -
                             self.coordinates['right_knee'].diff(self.time))
        
    def _set_angular_velocities(self):

        vec = self.speeds['left_hip'] * self.frames['inertial'].z
        self.frames['left_thigh'].set_ang_vel(self.frames['inertial'], vec)

        vec = self.speeds['left_knee'] * self.frames['left_thigh'].z
        self.frames['left_shank'].set_ang_vel(self.frames['left_thigh'], vec)
        
        vec = self.speeds['right_hip'] * self.frames['inertial'].z
        self.frames['right_thigh'].set_ang_vel(self.frames['inertial'], vec)

        vec = self.speeds['right_knee'] * self.frames['right_thigh'].z
        self.frames['right_shank'].set_ang_vel(self.frames['right_thigh'], vec)
        
        
    def _set_linear_velocities(self):

        self.points['hip'].set_vel(self.frames['inertial'], 0)
        
        self.points['lknee'].v2pt_theory(self.points['hip'],
                                         self.frames['inertial'],
                                         self.frames['left_thigh'])
        
        self.points['lankle'].v2pt_theory(self.points['lknee'],
                                         self.frames['inertial'],
                                         self.frames['left_shank'])
        
        self.points['lthigh_mass_center'].v2pt_theory(self.points['hip'],
                                         self.frames['inertial'],
                                         self.frames['left_thigh'])
        
        self.points['lshank_mass_center'].v2pt_theory(self.points['lknee'],
                                         self.frames['inertial'],
                                         self.frames['left_shank'])
        

        self.points['rknee'].v2pt_theory(self.points['hip'],
                                         self.frames['inertial'],
                                         self.frames['right_thigh'])
        
        self.points['rankle'].v2pt_theory(self.points['rknee'],
                                         self.frames['inertial'],
                                         self.frames['right_shank'])
        
        self.points['rthigh_mass_center'].v2pt_theory(self.points['hip'],
                                         self.frames['inertial'],
                                         self.frames['right_thigh'])
        
        self.points['rshank_mass_center'].v2pt_theory(self.points['rknee'],
                                         self.frames['inertial'],
                                         self.frames['right_shank'])
        
    def _create_inertia_dyadics(self):

        lthigh_inertia_dyadic = me.inertia(self.frames['left_thigh'], 0, 0,
                                        self.parameters['thigh_inertia'])
        
        lshank_inertia_dyadic = me.inertia(self.frames['left_shank'], 0, 0,
                                        self.parameters['shank_inertia'])
        
        rthigh_inertia_dyadic = me.inertia(self.frames['right_thigh'], 0, 0,
                                        self.parameters['thigh_inertia'])
        
        rshank_inertia_dyadic = me.inertia(self.frames['right_shank'], 0, 0,
                                        self.parameters['shank_inertia'])

        self.central_inertias = OrderedDict()
        self.central_inertias['lthigh'] = (lthigh_inertia_dyadic,
                                        self.points['lthigh_mass_center'])
        self.central_inertias['lshank'] = (lshank_inertia_dyadic,
                                         self.points['lshank_mass_center'])
        
        self.central_inertias['rthigh'] = (rthigh_inertia_dyadic,
                                        self.points['rthigh_mass_center'])
        self.central_inertias['rshank'] = (rshank_inertia_dyadic,
                                         self.points['rshank_mass_center'])
    
    def _create_rigid_bodies(self):

        self.rigid_bodies = OrderedDict()

        self.rigid_bodies['lthigh'] = \
            me.RigidBody('lthigh',
                         self.points['lthigh_mass_center'],
                         self.frames['left_thigh'],
                         self.parameters['thigh_mass'],
                         self.central_inertias['lthigh'])

        self.rigid_bodies['lshank'] = \
            me.RigidBody('lshank',
                         self.points['lshank_mass_center'],
                         self.frames['left_shank'],
                         self.parameters['shank_mass'],
                         self.central_inertias['lshank'])
            
        self.rigid_bodies['rthigh'] = \
            me.RigidBody('rthigh',
                         self.points['rthigh_mass_center'],
                         self.frames['right_thigh'],
                         self.parameters['thigh_mass'],
                         self.central_inertias['rthigh'])

        self.rigid_bodies['rshank'] = \
            me.RigidBody('rshank',
                         self.points['rshank_mass_center'],
                         self.frames['right_shank'],
                         self.parameters['shank_mass'],
                         self.central_inertias['rshank'])
            
    def _create_loads(self):

        self.loads = OrderedDict()

        g = self.parameters['g']

        vec = -self.parameters['thigh_mass'] * g * self.frames['inertial'].y
        self.loads['lthigh_force'] = (self.points['lthigh_mass_center'], vec)

        vec = -self.parameters['shank_mass'] * g * self.frames['inertial'].y
        self.loads['lshank_force'] = (self.points['lshank_mass_center'], vec)
        
        vec = -self.parameters['thigh_mass'] * g * self.frames['inertial'].y
        self.loads['rthigh_force'] = (self.points['rthigh_mass_center'], vec)

        vec = -self.parameters['shank_mass'] * g * self.frames['inertial'].y
        self.loads['rshank_force'] = (self.points['rshank_mass_center'], vec)
        
        vec = (self.specified['left_force_x'] * self.frames['inertial'].x
                + self.specified['left_force_y'] * self.frames['inertial'].y)
        self.loads['lcontact_force'] = (self.points['lankle'], vec)

        vec = (self.specified['right_force_x']  * self.frames['inertial'].x
                + self.specified['right_force_y'] * self.frames['inertial'].y)
        self.loads['rcontact_force'] = (self.points['rankle'], vec)
        

        vec = (self.specified['left_hip_torque'] * self.frames['inertial'].z -
               self.specified['left_knee_torque'] * self.frames['inertial'].z)
        self.loads['lthigh_torque'] = (self.frames['left_thigh'], vec)
        

        self.loads['lshank_torque'] = (self.frames['left_shank'],
                                      self.specified['left_knee_torque'] 
                                      *self.frames['inertial'].z)
        
        vec = (self.specified['right_hip_torque'] * self.frames['inertial'].z -
               self.specified['right_knee_torque'] * self.frames['inertial'].z)
        self.loads['rthigh_torque'] = (self.frames['right_thigh'], vec)
        

        self.loads['rshank_torque'] = (self.frames['right_shank'],
                                      self.specified['right_knee_torque'] 
                                      *self.frames['inertial'].z)
        
    def _setup_problem(self):
        self._create_states()
        self._create_specified()
        self._create_parameters()
        self._create_reference_frames()
        self._orient_reference_frames()
        self._create_points()
        self._set_positions()
        self._define_kin_diff_eqs()
        self._set_angular_velocities()
        self._set_linear_velocities()
        self._create_inertia_dyadics()
        self._create_rigid_bodies()
        self._create_loads()
        
    def _generate_eoms(self):

        self.kane = me.KanesMethod(self.frames['inertial'],
                                   list(self.coordinates.values()),
                                   list(self.speeds.values()),
                                   self.kin_diff_eqs)

        fr, frstar = self.kane.kanes_equations(list(self.rigid_bodies.values()), 
                                               list(self.loads.values()))

        fr_plus_frstar = sy.trigsimp(fr + frstar)
        
        sub = {self.speeds['left_hip'].diff(self.time):
                self.accelerations['left_hip'],
                self.speeds['left_knee'].diff(self.time):
                self.accelerations['left_knee'],
                self.speeds['right_hip'].diff(self.time):
                self.accelerations['right_hip'],
                self.speeds['right_knee'].diff(self.time):
                self.accelerations['right_knee']}
            
        self.fr_plus_frstar = fr_plus_frstar.xreplace(sub)
        
        return self.fr_plus_frstar, self.kane